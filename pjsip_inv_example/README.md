Задание:
--------

Необходимо реализовать автоответчик для SIP клиента на базе PJSIP и PJMEDIA.

Ожидаемая последовательность сообщений:

<pre>
SIP client             Autoanswer
  |     SIP INVITE         |
  |----------------------->|
  |     100 Trying         |
  |<-----------------------|
  |     180 Ringing        |
  |<-----------------------|
  |      200 OK            |
  |<-----------------------|
  |       ACK              |
  |----------------------->|
  |         RTP            |
  |<---------------------->|
</pre>

После ответа на звонок, в зависимости от вызываемого номера, необходимо:
- проигрывать wav файл;
- проигрывать непрерывный аудиосигнал - частота = 425 Гц;
- проигрывать повторяющися аудиосигнал - частота = 425 Гц, 1 секунда гудок, 4 секунды тишина.

Между 180 Ringing и 200 OK должна быть задержка в 1-2 секунды.
Звонок должен освобождаться автоматически через 15-20 секунд.

Решение:
--------

Файлы:
auto_answer.c
Makefile

Enum:
- auto_answer_dst_type_e - описание типов вызываемых абонентов: 1111 - wav, 
  2222 - аудиосигнал - частота = 425 Гц, 1 секунда гудок, 4 секунды тишина,
  3333 - непрерывный аудиосигнал - частота = 425 Гц. Для остальных номеров будет
  выставлено значение - eAUTO_ANSWER_DST_TYPE_NONE.
- auto_answer_tone_type_e - описание какие типы тонов есть в приложении.

Структуры:
- app_instance_t - хранит данные приложения:
  указатели на sip и media endpoint-ы, указатель на конференц-бридж, указатель на мастер и нулевой порты,
  на uri для звонка, массив звонков, конфигурационные данные (информация о портах для проигрывания тонов 
  и wav файла, имя wav файла, максимальное количество вызов, длительность звонка и т.д.).
- auto_answer_extension_t - структура хранит номер и ассоциированный с ним тип playback устройства.
- auto_answer_call_t - содержит информацию о звонке: id, указатель на invite сессию, тип вызываемого аббонента
  (wav, один из двух видов тонов или none), массив медиа информации (в приложении используется только 0-ой элемент),
  два таймера - для автоматического сброса вызова и для задержки в 1 секунду после отправки SIP 180 RINGING.
- auto_answer_call_media_t - содержит информацию о медиа: id для звонка и для медиа, указатели на stream, медиа порт, 
  слот на конференц бридже, информация о транспорте. 
 

Функции:
- auto_answer_dst_config() - заполнение массива структур с номерами для проигрывавния аудио-сигнала/wav файла.
- auto_answer_tone_config() - заполнение информации о тонах: частота, длительность.
- auto_answer_call_array_init() - инициализация массива звонков и медиа информации для каждого элемента массива.
- auto_answer_app_init() - инициализация данных приложения.
- auto_answer_sip_stack_init() - инициализация sip стека, регистрация модуля приложения для приема звонков.
- auto_answer_media_transport_init() - создание транспорта для ртп медиа для каждого звонка.
- auto_answer_media_init() - создание media endpoint, конференц-бриджа, добавление портов для проигрывания
  wav файла и тонов, так же создание null порта и мастер порта для проигрывания медиа стримов.
- auto_answer_translate_ext_to_dst() - получение типа playback устройства по набранному номеру.
- auto_answer_destroy_call_media() - удаление медиа порта и стрима, которые были созданы для звонка.
- auto_answer_app_destroy() - функция, которая вызывается при закрытии приложения 
  (в случае ошибки или при обычном выходе) и освобождает ресурсы.
- auto_answer_hangup_call() - завершение вызова по call_id.
- auto_answer_hangup_all_calls() - завершение всех вызовов.
- auto_answer_hangup_timer_cb() - callback функция для обработки таймера для автоматического освобождения
  вызова через 15 секунд.
- auto_answer_timer_cb() - callback функция для обработки задержки в 1 секунду после SIP 180 RINGING. 
  Функция отправляет SIP 200 OK сообщение.
- auto_answer_timer_start() - выделен в отдельную функцию старт таймера для задержки в 1 секунду.
- auto_answer_conf_connect() - выделено в отдельную функцию соединение портов на конференц-бридже в зависимости
  от типа вызываемого абонента. Функция вызывается из call_on_media_update() функции.
- on_rx_request() - callback функция для обработки входящего вызова. В ответ на SIP INVITE отсылается 
  SIP 100 TRYING и, затем, SIP 180 RINGING. Стартует таймер на 1 секунду.
- call_on_state_changed() - callback функция для обработки изменения состояния звонка. 
  В случае PJSIP_INV_STATE_DISCONNECTED состояния - вызывается функция для очищения медиа информации и так же
  для очищения информации о звонке. В случае PJSIP_INV_STATE_CONFIRMED состояния стартует таймер для автоматического
  сброса вызова через 15 секунд.
- call_on_media_update() - callback функция для обработки изменения состояния медиа информации. 
  Стартует медиа в зависимости от типа вызываемого абонента.
- auto_answer_console_output() - выводит информацию о том, как пользоваться приложением и ожидает ввода команды 
  с консоли.
- worker_proc() - отдельный поток для опроса ioqueue событий.
- main() - инициализирует и стартует приложение. Ожидает звонка.

Максимальное количество обрабатываемых звонков = 20. При превышении максимального количества вызовов
будет отправляться SIP 486 BUSY сообщение.

Makefile:
По умолчанию приложение будет собиратся для x86_64 платформы.
Для ARM архитектуры необходимо выполнить команду:
make COMPILER=arm
pjproject папка содержит библиотеки для компиляции.

track.wav - wav файл, который будет проигрываться при звонке на номер 1111.

Ссылка на git репозиторий:
--------------------------
git@gitlab.eltex.loc:marina.glynina/auto-answer-test-task.git

GitLab link: https://gitlab.eltex.loc/marina.glynina/auto-answer-test-task

Тесты:
-------
- Все сценариий проверены на x86-64 и arm архитектурах.
Тест 1:
1. Зарегистрировать SIP клиента и набрать один из номеров: 1111, 2222, 3333.
2. Проверить, что проигрывается соответствующее аудио: wav файл, прерывистый тон, непрерывный тон.
3. Проверить несколько звонков одновременно. Аудио проигрывается.

Тест 2:
- установить sipp;
- папка sipp_traffic в репозитории содержит xml и csv, используемые для генерации траффика.
1. Монитор звонков в течение часа:
   sipp -sf uac_test.xml -inf extension.csv -l 20 -i 10.25.72.97 192.168.23.149:5062.
2. Проверить, что нет ошибок и приложение продолжает работать.
   Результат теста в файле - sipp_results в репозитории.
3. Запустить команду:
   sipp -sf uac_test.xml -inf extension.csv -m 22 -l 22 -i 10.25.72.97 192.168.23.149:5062.
4. Проверить, что нет ошибок и приложение продолжает работать. В результатах 2 failed звонка.
   На эти звонки со стороны приложения было отправлено SIP 486 BUSY сообщение.
